//Class that represents all nodes.
import java.util.Map;

public class Node{
    private float _posX, _posY;
    private float _size;
    private ArrayList<Edge> edges;
    private HashMap<Node, Integer>edgeCount;

    private int _r, _g, _b;

    Node(float x, float y){
        _posX = x;
        _posY = y;
        _size = 50;
        edges = new ArrayList<Edge>();
        edgeCount = new HashMap<Node, Integer>();
    }

    Node(float x, float y, float size){
        _posX = x;
        _posY = y;
        _size = size;
        edges = new ArrayList<Edge>();
        edgeCount = new HashMap<Node, Integer>();
    }
    
    public void setFill(int r, int g, int b){
        _r = r;
        _g = g;
        _b = b;
    }

    public void setPosition(float x, float y){
        _posX = x;
        _posY = y;
    }

    public float getPositionX(){
        return _posX;
    }

    public float getPositionY(){
        return _posY;
    }

    public float getRadius(){
        return _size/2;
    }

    public float getCenterX(){
        return _posX; //+ (_size/2);
    }

    public float getCenterY(){
        return _posY; //+ (_size/2);
    }

    public ArrayList<Edge> getList(){
        return edges;
    }

    public void addEdge(Edge e){
        boolean check;
        Node endNode;

        if(e.getPosOneNode() != this){
            check = edgeCount.containsKey(e.getPosOneNode());
            endNode = e.getPosOneNode();
        }
        else{
            check = edgeCount.containsKey(e.getPosTwoNode());
            endNode = e.getPosTwoNode();
        }

        edges.add(e);

        if(check){
            Integer count = edgeCount.get(endNode);
            edgeCount.put(endNode, count+1);

            handleParralelEdges(endNode);
        }
        else{
            edgeCount.put(endNode, 1);
        }
    }

    private void handleParralelEdges(Node end){
        boolean oddCount = ((edgeCount.get(end) % 2) == 1);
        int offset = oddCount?0:5;

        println(oddCount);
        for(Edge e: edges){
            if (e.getPosOneNode() == end || e.getPosTwoNode() == end){
                //println(offset);
                e.setOffset(offset);

                switch(offset){
                    case 0: 
                        offset = 10;
                    break;
                    default :
                        offset = abs(offset)!=offset?((offset-10) * -1):(offset*-1);
                    break;	
                }
                //println(offset);
            }
        }
    }

    public boolean clicked(float x, float y){

        float distance = sqrt(pow((_posX-x), 2) + pow((_posY-y), 2));
        return (distance < (_size/2));
        
    }

    public void displayEdge(){
        for(Edge e: edges){
            e.update();
            e.display();
        }
    }

    public void display(){
        fill(_r, _g, _b);
        
        ellipse(_posX, _posY, _size, _size);

        fill(50);
        text(edges.size(), _posX-2, _posY);
    }
}
